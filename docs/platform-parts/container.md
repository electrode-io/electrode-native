## Electrode React Native Container

### What is a Container ?

A `Container`, from a high level perspective is actually nothing more than a native library which does not look any different from any other third party library that Android and iOS developers are used to consume.  

It is entirely generated by `Electrode React Native` platform and packaged as an `AAR` library for Android and an ` Framework` for iOS. 

Each mobile application will get its own custom `Container`, with just the "things" it needs.

### What's inside a Container ?

What are these "things" ?  
Well, let's take a closer looks inside a `Container` to see what it actually contains :

- The `MiniApps`   
In the form of a single `JavaScript` bundle. This bundle actually contains all the `JavaScript` code of all the `MiniApps` part of of a `Container`. Because we do not -yet- have `multi bundle` support, we actually bundle all `MiniApps` together.

- The `MiniApps` assets  
Mostly `fonts` and `images` assets being used by the `MiniApps`.

- The `MiniApps` native dependencies
All the native dependencies that `MiniApps` directly or transitively depends on.   
`react-native` itself is one native dependency, but it also includes third party native modules (`react-native-maps`, `react-native-vector-icons`, `react-native-electrode-bridge`) or platform `APIs`.

- Additional native dependencies
Some native dependencies not being direct or transitive dependencies of the `MiniApps`. Mostly native platform `APIs implementations` as well as some third party native modules that are only used from the mobile application side (very rare).

- Container specific code  
A `Container` contains some code exposed to mobile application developers to properly integrate a `Container` in their mobile application. This mostly consist of code to intialize the `Container` along with some utility code to access and deal with the `MiniApps` stored within.

### Container publication

As initially mentioned, a `Container` is fully generated by `Electode React Native` based on the `MiniApps` and specific `native dependencies` you want to include in it. That being said, the resulting `Container` also needs to get published in some central location. Keeping it local to your machine has its uses (for example to laucnh a `MiniApp` in the `Runner`, or for development/experimentation needs), but for the most part you'll want to publish your `Container` so that it can be properly added to your `mobile aplication`.

`Electrode React Native` offers two `publishers` for `Container`, as of now : `Git` and `Maven`.

`Maven` publisher can only be used for an `Android Container`. Upon generation of a `Container`, this publisher will actually compile the resulting library project, and will publish the resulting `AAR` to a `Maven` repository of your choice (can be your own custom `Nexus` for example).

`Git` publisher can be used for both `Android or iOS Container`. Upon generation of a `Container`, this publisher will publish the whole generated `Container` project to a `Git` repository of your choice (`GitHub` most probably).

A `Container` is versioned. Every time you'll re-generate a `Container`, its version will be updated. For `Maven` publisher, the version will be part of the `AAR` artifact. For `Git` publisher, we will use a git `tag` for the version.

Because `Containers` are in part composed of `native code`, they only make sense during the development lifecycle of a mobile application version. You can not use a newly generated `Container` in a mobile application version that has already been released. If you want to update `MiniApp(s)` code as an OTA update, this does not involve the generation of a new `Container` at all, as it is not possible to ship native code over the air.

### Configuring container publication

`Container` publication configuration is part of the `containerGenerator` configuration object. This configuration is stored in the `Cauldron`, so that it can be shared across users. You should add your own configuration manually to the `Cauldron` (we don't have yet command support for this).
The `config` object should be stored under a specific `platform` level in the `Cauldron`.
Here is a sample configuration :

```json
"nativeApps":[
   {
      "name":"MyWeatherApp",
      "platforms":[
         {
            "name":"android",
            "config":{
               "containerGenerator":{
                  "containerVersion":"1.0.0",
                  "publishers":[
                     {
                        "name":"github",
                        "url":"git@github.com:user/myweatherapp-android-container.git"
                     },
                     {
                        "name":"maven",
                        "url":"http://user.nexus.repo.com:8081/nexus/content/repositories"
                     }
                  ]
               }
            }
         },
         {
            "name":"ios",
            "config":{
               "containerGenerator":{
                  "name":"github",
                  "targetRepoUrl":"git@github.com:user/myweatherapp-ios-container.git",
                  "containerVersion":"1.0.0",
                  "publishers":[
                     {
                        "name":"github",
                        "url":"git@github.com:user/myweatherapp-ios-container.git"
                     }
                  ]
               }
            }
         }
      ]
   }
]
```

#### Android
The `publishers` array contains all the `publishers` you want to use to publish a `Container`. In this example we want to publish the `Container` of `MyWeatherApp Android` to two different destinations : a `GitHub` repository, as well as a `Maven` repository. For the `github` repository, the code of the `Container` will be published and a `git tag` will be used for the version. For the `maven` repository, the `Container` will be compiled and the resulting versinoned `AAR` will be published to the `maven` repository.

#### maven publisher remarks

- `maven` publisher can only be used for the `android` platform. 
- You'll need to have a global `gradle.properties` file on your workstation (`~/.gradle/gradle.properties`) containing the `maven` username and password to use for publication, as follow :
``` 
mavenUser=user
mavenPassword=password
```

#### iOS
The `publishers` array contains all the `publishers` you want to use to publish a `Container`. In this example the `Container` of `MyWeatherApp iOS` will be published to the `GitHub` repository and use `git tag` for the version. 

### Adding a `Container` to your mobile application

This is a one time procedure

#### Android

A Container library can be added to a mobile Android application project in two different ways. Either by directly adding the Container module to the Android project, as a git submodule, or by adding a dependency on the Container AAR (recommended way).

In both cases, you'll also need to slightly update your `build.gradle` files, to address the following :

- jcenter repository

We publish `react-native` maven artifact to `jcenter`. Therefore, you need to make sure that `jcenter` is present in your list of `repositories` (repositories as most commonly defined in your top level project `build.gradle`)

```groovy
repositories {
  jcenter()
  //...
}
```

- resolution strategy

React native comes with some third party libraries that might conflict with the versions you are using. You might have issues with `jsr305`. If that is the case, just add the following to your application module `build.gradle`

 ```groovy
configurations.all {
  resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.0'
  //...
}
```

You might also need some more resolution strategies. Indeed, React Native depends on a specific version of a very popular networking library, `OkHttp`. If you are using this library in your application, you might be forced to align your version of `OkHttp` with the one shipped with the React Native version you are using (or use a resolution strategy, which is somehwat similar).  
This is quite a bummer, but it's due to React Native design, and not easily fixable, unless React Native goes into deep refactorings to not tightly depend on `OkHttp`.

- okio linting

You might run into some problems with `okio` third party library which comes with React Native. It is a known "issue". If that is the case, just diable the lint check for `InvalidPackage` (other solutions can be found by googling this okio problem).

```groovy
lintOptions {
  disable 'InvalidPackage'
  //...
}
```

That being said, and done, let's look into the two ways of adding the Container to a mobile application project

**As an AAR dependency**

If a `maven` publisher has been configured in the Cauldron, Electrode React Native will package and publish the Container project as a maven artifact containing the AAR, either to maven local or to a remote Maven repository. 

By default, if no publisher is configured in the Cauldron, Electrode React Native will publish the container to your maven local repository (located in `~/.m2/repository`)

The Container maven artifact will have the following group ID, artifact ID and version string :

- Group ID : `com.walmartlabs.ern`
- Artifact ID : `{mobile-app-name}-ern-container`
- Version string : `{container-version}`

`{mobile-app-name}` will be replaced by the name of the mobile application in the Cauldron for which the Container is being generated. For example, if the application name is `walmart`, the Container artifact ID will be `walmart-ern-container`.
 
`{container-version}` will be the version of the generated Container. Container versions can only take the form `x.y.z` where x, y and z are integers. For example `1.2.3` is a vaid Container version. You can explictely specify a version for a Container, otherwise the current version will be patched bumped upon new generation.

To add a dependency on the Container, in your mobile application, just add the following to the `dependencies` object of your application module `build.gradle` 

```groovy
dependencies {
  compile('com.walmartlabs.ern:{mobile-app-name}-ern-container:{container-version}')
  //...
}
```

Just substitute the `{mobile-app-name}` and `{container-version}` accordingly.

Also, if you are using, or wish to use a locally generated Container, make sure to declare `mavenLocal` repository in the list of `repositories` (top level project `build.gradle`)

```groovy
repositories {
  mavenLocal()
  //...
}
```

**As a module in the project**

The second way to include a Container in a mobile application, is adding it as an Android module. This is not the recommended way to add third party dependencies (Container being one) to an Android project, but this is still possible, and might be the easiest way if you don't have a rremote Maven repository that you can publish the Container to.

To achieve this, you should add a `GitHub` publisher to the Cauldron. This way, upon generation of a new Container version, Electrode React Native will publish the resulting project to a private or public `GitHub` repository. It will create a git `tag` for each version of a Container.  
From there, you can just add the Container Android module to your application project (managed as a git submodule most probably).  

If you are going down this road, please be wary that you should not edit the code of Container. Indeed, adding the Container directly in your project, will make its code editable. The Container code should not be modified manually, as any custom modification will be lost upon next generation of the Container.

You'll need to `include` the module in your project `settings.gradle`, and add a `compile project` directive to your application module `build.gradle`.

#### iOS

A Container can be added as a dependency to a Xcode project in two different ways. Either through dependency manager like Carthage (We will provide support for Cocoapods in the future) or through manual installation. 

**Carthage**
Create a `Cartfile` if you don't have one or open your existing one.
Add the following line to your `Cartfile`. 
```
git "git@github.com:user/myweatherapp-ios-container.git" "v1.0.0"
```
Create a `Cartfile.resolved` if you don't have one or open your existing one.
Add the following line to your `Cartfile.resolved`
```
git "git@github.com:user/myweatherapp-ios-container.git" "v1.0.0"
```
Now you can install your dependencies using the command. 
```
$ carthage bootstrap --no-build --platform ios
```

**Manual Installation**

To manully install container, clone the container to `<Your-WorkSpace>` 
```
$ git@github.com:user/myweatherapp-ios-container.git
```
Open your project in Xcode and right click on `Libraries` to select `Add Files to <your project name>` Look for `ElectrodeContainer.xcodeproj` in the file directory where you cloned the repo above. 

**Additional Config**
After installing the dependency, you will have to do some additional configs as below. 
Choose `<your project>` from project navigation panel. Then click `<your project>` under `TARGETS`. Go to `Genral` tab. Find `Embedded Binaries`, click `+` and find `ElectrodeContainer.framework` and `add`. 
Now go to `Build Phases` double check `ElectrodeContainer` are in `Target Dependencies`, `Linke Binary With Libraries` and `Embed Frameworks`

### Initializing a `Container`
#### Android
Before accessing MiniApps stored within a Container, it needs to be initialized.

Initialization of a Container should ideally take place during startup of your mobile application. If you are using a class extending `Application` you should place the Container initialization call in the `onCreate` method of this class. If you are not using an `Application` class to initialize all libraries used by your mobile application, you should place the Container initialization code wherever you see fit. The sooner it gets initialized, the better.

Initialization of Container is done as a single call of the `initialize` static method of `ElectrodeReactContainer` class.

```java
ElectrodeReactContainer.initialize(
            this /* Application instance */,
            new ElectrodeReactContainer.Config().isReactNativeDeveloperSupport(BuildConfig.DEBUG)
            /* Aditional plugins configuration here */);
```

The first parameter to this method is the `Application` instance. In the sample call above we use `this` as this call is made from an `Application` extending class).  
The second parameter is the configuration of the `Container` and React Native. In the sample above we juse enable React Native developper support. In the sample call above, we make use of `BuildConfig.DEBUG` to enable developer mode for debug builds only. You might want to adapt it for your application needs.  

The `initialize` method might also contain additional parameters. Repectively, one parameter per plugin confgiuration. Not all plugins (APIs or third party native modules) are `configurable`, so most of them (>90%) won't add an extra parameter to the `initialize` method. One configurable plugin is `react-native-code-push` for example, as you need to pass a `deployment key` to initialize this plugin, and it also has a `debug mode` that you can enable or disable.

To learn more about configurable plugins, please refer to the section [url](url)

#### iOS

Before accessing MiniApps stored within a Container, it needs to be initialized. In iOS, we prefix our platform specific files with `Electrode`. 

Initialization of a Container should ideally take place during startup of your mobile application. Ideally it should take place in your `AppDelegate.m` in `didFinishLaunchingWithOptions:` method. Otherwise, you shoud call Container initialization wherever you see fit. The sooner it gets initialized, the better. 

Initialization of Container is done through the static method `startWithConfigurations:` of `ElectrodeReactNative`. 
```ObjC
    ElectrodeContainerConfig *containerConfig = [[ElectrodeContainerConfig alloc] init];
    containerConfig.debugEnabled = RnDevSupportEnabled;
    [ElectrodeReactNative startWithConfigurations:containerConfig];
```

The first parameter is an implementation of `ElectrodePluginConfig` protocol we provide through `ElectrodeContainer` that allow you to config for both `ElectrodeContainer` and React Native. In the sample above we use `RnDevSupportEnabled`, a static boolean constance, to decide if developer support should be enabled or not. You might want to adapt it for your application needs.  

The `startWithConfigurations:` method might also take additional parameters like implementation of `ElectrodePluginConfig` for additional plugins, depending on your plugin dependencies. Specifically, one parameter per plugin confgiuration. Note that not all plugins (APIs or third party native modules) are `configurable`, so most of them (>90%) won't add an extra parameter to the `initialize` method. One configurable plugin is `react-native-code-push` for example, as you need to pass a `deployment key` to initialize this plugin, and it also has a `debug mode` that you can enable or disable.

To learn more about configurable plugins, please refer to the section [url](url)

### Launching a MiniApp
#### Android
When a Container is generated, it will create one `Activity` for each MiniApp included in the Container. For example, if you have a MiniApp named `Hello`, the container will create an Activity extending class named `HelloActivity`. It will also be declared in the `AndroidManifest.xml` of the Container, so that you can launch it from your mobile application without extra setup.  

All of these Activties are stored in the `com.walmartlabs.ern.container.miniapps` namespace.

To launch a MiniApp, all you have to do then, is start its corresponding `Activity`.

You can also pass initial properties to a MiniApp, which will be provided to the JS MiniApp as props in `componentWillMount` React lifecycle. This might be useful if the MiniApp needs some data upon first launch.  

To do this, just call the following static method of `ElectrodeMiniAppActivity` class. The first parameter is the `Intent` instance that you will pass to `startActivity`, while the second parameter is a `Bundle` instance containing the data to provide to the MiniApp as key/value pairs.

```java
public static void addInitialProps(@NonNull Intent intent, @NonNull Bundle bundle)
```

These generated Activities are very basic, and might not fullfil your more advanced needs. If you would like instead to use your own `Activity` subclass to "host" a `MiniApp`, you can directly extend the `ElectrodeMiniAppActivity` class and override the methods to your needs.  

If you go down this road, please make sure to override the following method, and return the String correspoding to the MiniApp name hosted by this Activity (using the previous example, we would return "Hello")

```java
protected String getMiniAppName()
```

If you cannot extend your own `Activity` from this one (you might already have a deep inheritance chain and Java does not support multiple inheritance) but roll your own, or host the MiniApp in a `Fragment` instead, then you'll have to take a closer look to `ElectrodeMiniAppActivity` and use it as a template to roll your own class.

#### iOS

When a Container is generated, it provide one `UIViewController` for each MiniApp included in the Container. For example, if you have a MiniApp named `Hello`, the container will create a `UIViewController` that contains the `Hello` miniapp and it's  the usual `UIViewController` you are already familiar with. 

To launch a MiniApp, all you have to do then, is present its corresponding `UIViewController` by calling `[[ElectrodeReactNative sharedInstance] miniAppWithName:@"<your-mini-app-name>" properties:nil]`

You can also pass initial properties to a MiniApp, which will be provided to the JS MiniApp as props in `componentWillMount` React lifecycle. This might be useful if the MiniApp needs some data upon first launch.  

To do this, just pass a `NSDictionary` to the parameter `property`

These generated `UIViewController` are very basic and might not fullfil your advanced need. If you would like to use your own subclass of `UIViewController` you just need to override `viewDidLoad:` in your `UIViewController`. 

```ObjC
- (void)viewDidLoad {
    [super viewDidLoad];    
    UIViewController *viewController =
    [[ElectrodeReactNative sharedInstance] miniAppWithName:@"<YourMiniAppName>" properties:nil];
    viewController.view.frame = [UIScreen mainScreen].bounds;
    [self.view addSubview:viewController.view];
}
```

### Related commands

- `ern create-container`  
Create (generate) a Container locally without publishing it. It should rarely be of use in your workflow as it does not allow remote publication of the generated Container. This command will mostly be used for specific development/experimentation purposes.

- `ern cauldron add/del/update dependencies` and `ern cauldron add/del/update miniapps`  
Given that a `Container` contains `MiniApps` and `native dependencies`, every time you'll want to add/delete/update `MiniApps` or `native dependencies` to your `Container`, it will be regenerated, and published (with a new version) to correctly reflect the changes.  
That is, every time you'll make use of an `ern cauldron` subcommand that add/delete or update `MiniApp(s)` or `native dependency(ies)` for a given non-released mobile application version, behind the scene, a new `Container` version will automatically be re-generated and published.

- `ern run-android` and `ern run-ios`  
These two commands will generate a local container that will include your `MiniApp` along with its native dependencies and will be used by the `Runner` application project to launch your `MiniApp`.
