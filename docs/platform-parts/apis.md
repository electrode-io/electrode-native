## Working with APIs

### What are APIs ?

If you are working with `React Native`, at some point you'll probably need one or more `MiniApp(s)` to interact with your mobile application(s), either to get access to some data or trigger some actions. Or the opposite. It might be the mobile application(s) that might need to get some data or trigger some actions from/in the `MiniApp(s)`.

That's where `APIs` are coming into play.

Powered by the `Bridge` and fully generated by `Electrode React Native` from a `Swagger` schema, `APIs` allows for fine grained and type safe communication between the native side and the JavaScript side.

Any given `API` comes in two parts : the `API` project itself and the `API implementation`.

### The API project

This is what `Electrode React Native` will generate for you, based on a `Swagger` schema. Generation will result in a cross platform `API` project, including the `client` code of the `API`, for all three platforms (JS/Android/iOS), along with the optional `models` part of of this `API`. Any given `MiniApp` or `mobile application` can then include and use this `API`.

The generated code also contains necessary hooks to actually implement the `API`. Indeed, an `API` without an actual implementation is of no real use (for example if your `movie API` contains a `getAllMovies` client request, there needs to be, somewhere, some code that is going to process this request and return the collection of all movies).

The implementation of an `API` is not part of the `API` itself. We keep `API` and `API implementation` separate. One of the reason being to allow multiple implementations for any given `API` and offer the possibility to switch between implementations.
Therefore, once the `API` is generated, you should not in any way modify it. It contains only generated code. Any regeneration of it (following a schema update) will actually overwrite any custom user code modifications.

Generated `APIs` follow a naming convention : `react-native-[name]-api`

### API implementation

`API implementations` won't get fully generated for you, for obvious reasons, `Electrode React Native` can't know what your implementation will actually do.    
`Electode React Native` still generate some code though, to help you kickstart `API implementations` projects.

An `API implementation` project implements a specific given `API` (to reuse the previous example, it will implement the actual logic behind `getAllMovies` request). That being said an `API implementation` project can only be done on one "side", i.e you can either do a native implementation of the API (iOS and/or Android) or a JavaScript implementation of it. But not both. At least not in the same `API implementation` project.  

However, considering that there can be multiple implementations for a given `API`, it is totally possible to have an JavaScript implementation and a native implementation of the same `API`. It will just be two different `API implementations` projects. And of course, for any given `API` you can only have a single implementation of it during runtime.

### Versioning APIs

APIs offers a few advantages compared to React Native native modules. First of all, because they are generated, they don't need any specific Container injection (linking) configuration. Also, Electrode React Native is less strict when it comes to API native compabitily checks compared to native modules.  

Indeed, for native modules versions, the platform will not allow versions mismatch. If two different versions (even patch versions) of an identical native module are used by two different MiniApps, platform won't allow adding both MiniApps. Native modules versions needs to be an exact match, down to the patch version.

However, for APIs (and API implementations), Electrode React Native is less strict with versions checks, as long as you adopt the following guidelines for versioning your APIs :  

- **Patch version bump** *(i.e 1.0.0 => 1.0.1)*   
When your API does not contain any changes to its public surface, but only to its internals. Because APIs are fully generated, and not to be modified manually, this should only happen when you regenerate an API following a platform version update which contain some internal changes (bug fixes or improvements) to our API generator.   
For API implementations, you should patch bump if you are making modifications to your implementation.  

- **Minor version bump** *(i.e 1.0.0 => 1.1.0)*
When your API contains new requests or new events.

- **Major version bump** *(i.e 1.0.0 => 2.0.0)*
When your API contains breaking changes to its public surface. For example if you remove (or rename) an existing request or event.

Electrode React Native will offer more flexibility for deploying MiniApps that are using APIs versions not striclty aligned with APIs versions present in the Container.

- **API with a different patch version**  
When trying to deploy a MiniApp that contains an API version that exists in the Container with a different patch version (greater or lower), Electrode React Native will assume binary compatibility in any case.  

- **API with a different minor version**
When trying to deploy a MiniApp that contains an API version that exists in the Container with a different minor version, Electrode React Native will assume binary compatibility only if the version stored in the container is greater than the one used by the MiniApp.

- **API with a different major version**
When trying to deploy a MiniApp that contains an API version that exists in the Container with a different major version, Electrode React Native will consider binary incompability and will not allow deployment.

### API guidelines

While the recommand approach to implement `APIs` is in a dedicated standalone project, which favor reuse and allows for switching implementations, it might not be possible in your context to implement a standalone `API`. For example if your native `API implementation` is very dependent on your mobile application itself, you might want to perform the `API implementation` directly inside your mobile application. This is totally possible, however we really don't recommended this tight coupling approach, but we understand that it sometimes might be the easiest path to follow.

`MiniApps`, if possible, should not directly depend on `API implementations`. Indeed, this makes switching between `API implementations` for the same `API` more complex. `MiniApps` should therefore ideally only depend on `APIs`. That being said, `MiniApps` can have some `API implementations` as development dependencies only. This way, if we consider an `API` with a native implementation of it (iOS and Android), it can be possible to have a cross platform `JS` mock implementation of it, that can be used during development to launch the `MiniApp` standalone.

Generated standalone `API implementations` follow a naming convention : `react-native-[name]-api-impl`.

### Related commands

- `ern create-api`  
Creates (generates) a new `API` project based on a `Swagger` schema

- `ern regen-api`  
Regenerates an existing `API` project following `Swagger` schema updates

- `ern create-api-impl`  
Creates (generates) a new `API implementation` project (native or JS)
